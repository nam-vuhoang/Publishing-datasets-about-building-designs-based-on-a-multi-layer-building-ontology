%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Converting EXPRESS Schemas to OWL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generating ifcOWL Ontologies From IFC Specifications}
\label{sec:ifcOWL}
This section describes the derivation of the ifcOWL ontologies from the IFC specification. Since there are different options for the conversion, the choices are presented as conversion principles with justiciations. 

\subsection{Common Conversion Principles}

\begin{principle}[Simple OWL profiles]
\ifcowl{} should be compatible with as simple OWL 2 profiles as possible (to support a maximum variety of reasoners and other tools). 
\end{principle}

The first layer \ifcsimple{} can be specified to be compatible with any OWL 2 DL profile: OWL 2 EL, OWL 2 QL or OWL 2 RL. The other layers \ifcstandard{} and \ifcextended{} are compatible with OWL 2 RL\footnote{Our WebIFC converter tool allows forced choice of other OWL profiles for any layer: OWL Lite, OWL DL, OWL Full, and OWL 2 Full}. OWL 2 RL needed because it -- unlike OWL 2 EL or QL -- supports 
union data\-types (see \ref{subsec:ifcOWL-select-types}), enumerations of individuals (see \ref{subsec:ifcOWL-enum-types}), and anonymous individuals (see \ref{subsec:ifcRDF-naming-individuals}) required by the IFC schema. \cite{w3c:owl2-profiles}

\begin{principle}[No domain and range restrictions]
Property names should be kept simple and therefore domain and range constraints (specified by \name{rdfs:domain} and \name{rdfs:range}) should not be included in \ifcowl{} ontologies.
\end{principle}

In the IFC schema the property names are \emph{local} to entity classes while in RDF they are \emph{global}. 
In IFC the same property name can appear in multiple different classes. If the domain and range restrictions
were included in  \ifcowl{}, the property names would need to be qualified with entity class names. This 
would reduce the readability and usability of the \ifcowl{} significantly. In \ifcowl{} the domain and 
range restrictions would mainly be used to infer types, since there is no need to check type constraints 
like in programming languages \cite{w3c:owl-guide}. Moreover, the basic facilities given by them do not 
provide any direct way to indicate property restrictions that are local to a class \cite{w3c:rdf-schema}. 
Although it is possible to combine use \name{rdfs:domain} and \name{rdfs:range} with sub-property hierarchies, 
direct support for such declarations is provided by OWL constructs, e.g. \name{owl:\-onProperty}.

\begin{principle}[Namespaces]
All constructs related to EXPRESS, STEP or IFC specifications must be belong to namespaces shown below with prefixes \name{expr:}, \name{step:} and \name{ifc:} accordingly (instead of \name{IFCXXX} there should be the name of IFC version, e.g. \name{IFC4_ADD1}):
%\name{IFC2x3} or \name{IFC4}):
%At this moment the namespaces are defined as below (instead of \name{IFCXXX} there should be IFC versions, e.g. 
%\name{IFC2x3} or \name{IFC4}):

%\begin{lstlisting}[caption={Namespace definitions},label=lst:ifcOWL-namespaces]
\begin{lstlisting}
@prefix expr: <http://drumbeat.cs.hut.fi/owl/EXPRESS#>
@prefix step: <http://drumbeat.cs.hut.fi/owl/STEP#>
@prefix ifc: <http://drumbeat.cs.hut.fi/owl/IFCXXX#>
\end{lstlisting}
\end{principle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Components of an EXPRESS schema
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Components of an EXPRESS schema}
The IFC specification is written as an EXPRESS schema. An EXPRESS schema defines series of data\-types, functions and rules by using EXPRESS data definition language specified in ISO10303-11 \cite{wiki:express,noauthor:ifc-guide}.

There are six groups of data\-types: simple data\-types, entity data\-types, enumeration data\-types, defined (declared) data\-types, select data\-types and aggregation data\-types. All types must be declared obviously by using constructs TYPE and ENTITY except the built-in simple data\-types. Definitions and characteristics of data\-types are considered below. EXPRESS schemata also contain definitions of functions, rules and type constraints most of which cannot be reflected in OWL 2 at all.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Simple Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simple Datatype Declarations}
\label{subsec:ifcOWL-simple-type}

Simple data\-types built in EXPRESS are: \name{STRING}, \name{BI\-NA\-RY}, \name{IN\-TE\-GER}, \name{REAL}, \name{NUM\-BER}, \name{BOO\-LEAN} and \name{LO\-GI\-CAL}. However, type \name{LOGICAL} which has three possible values \name{TRUE}, \name{FALSE} and \name{UNKNOWN} is considered by us as an enumeration data\-type (see \ref{subsec:ifcOWL-enum-types}). The same to type \name{BOOLEAN} which is like a primitive boolean data\-type but semantically close and met with the same frequency in IFC4 as \name{LOGICAL}.

\begin{principle}[Simple data\-types]
All simple data\-types except \emph{BOOLEAN} and \emph{LOGICAL} are declared as the same as their most similar primitive XSD data\-types which are supported by OWL 2 \cite{w3c:owl2-profiles} and are among preferred standard data\-types in Linked Data Platform \cite{w3c:ldp-best-practices}:

% \begin{lstlisting}[caption={Simple data types}, label=lst:ifcOWL-simple-types]
\begin{lstlisting}
expr:STRING, ifc:IfcGlobalUniqueId owl:sameAs xsd:string .
expr:BINARY owl:sameAs xsd:hexBinary .
expr:INTEGER owl:sameAs xsd:integer .
expr:REAL, expr:NUMBER owl:sameAs xsd:double .
\end{lstlisting}
\end{principle}

`Most similar XSD data\-types' mean the types from XSD schema that conform to the value spaces of the original EXPRESS and IFC data\-types better than other ones. For instance, type \name{xsd:double} is more similar to \name{REAL} than \name{xsd:decimal} as it is an IEEE 64-bit floating-point data\-type and supports scientific notation \cite{w3c:xsd,datapic:xsd}. It is recommended to use XSD data\-type names directly when they are needed.

\begin{principle}[Simple data\-types with sizes, ifcOWL layers: all]If \name{STRING} and \name{BINARY} data\-types are specified with a size parameter, i.e. \name{STRING (max\-Length\-In\-Bytes)} or \name{BINARY(size\-In\-Bits)}, then in layers \simple{} and \standard{} they are defined as equivalent to data\-types without size. But in layer \extended{}, the size parameter must be declared by using property \name{owl:onDatatype} and data\-type facets \name{xsd:maxLength} or \name{xsd:length} \cite{w3c:owl2-syntax,w3c:xmlschema11-2}, for instance:

% \begin{lstlisting}[caption={Size constraint of simple datatypes},label=lst:ifcOWL-simple-types-with-size]
\begin{lstlisting}
# only for Simple, Standard layers
expr:STRING22 owl:sameAs expr:STRING .

# only for Extended layer
expr:STRING22 owl:equivalentClass
    [   a rdfs:Datatype ;
        owl:onDatatype  xsd:string ;
        owl:withRestrictions ( [ xsd:length "22"^^xsd:integer ] ) ] .
\end{lstlisting}
\end{principle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Enumeration Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Enumeration Datatype Declarations}
\label{subsec:ifcOWL-enum-types}

An enumeration data\-type represents a set of possible fixed values. 

\begin{principle}[Enumeration data\-types]
Each enumeration data\-type in \textbf{ifc\-OWL} is defined as an \name{owl:Class} which is a subclass of \name{expr:\-Enum\-Class}. All possible values of enumeration data\-types are defined as named individuals. Enumeration data\-type memberships are defined by means of \name{rdf:type} in the \simple{} layer, and by means of \name{owl:oneOf} in \standard{} and \extended{} layers as shown below:
% \begin{lstlisting}[caption={Enumeration data\-types}, label=lst:ifcOWL-enum-types]
\begin{lstlisting}
# only for Simple layer
ifc:IfcAssemblyPlaceEnum a owl:Class ; rdfs:subclassOf expr:EnumClass .
ifc:SITE, ifc:FACTORY, ifc:NOTDEFINED rdf:type ifc:IfcAddressTypeEnum .
    
# only for Standard, Extended layers
ifc:IfcAssemblyPlaceEnum a owl:Class ;  rdfs:subclassOf expr:EnumClass ;
    owl:oneOf ( ifc:SITE ifc:FACTORY ifc:NOTDEFINED ) .
\end{lstlisting}
\end{principle}

The reason of two different approaches is that enumeration with more than one individual or literal are not supported in OWL 2 EL or QL. In both cases enumeration values are defined as individuals of one class so in terms of reasnoning logic they are equivalent. The enumeration values are defined as individuals because OWL 2 RL supports \name{Object\-One\-Of} to define enumeration of individuals, but not \name{Data\-One\-Of} \cite{w3c:owl2-profiles}. The fact that some values such as \name{ifc:NOT\-DE\-FI\-NED} belong to different enumeration data\-types should not cause any problems since all enumeration values in ifc\-RDF datasets are defined together with a concrete enumeration data\-type (see \ref{subsec:ifcRDF-enum-values}). It is also very easy to get all possible values of an enumeration data\-type by using simple SPARQL queries.

As mentioned above, simple data\-types \name{BOOLEAN} and \name{LOGICAL} are considered by us as enumeration data\-types. But these types and their values must be defined in the EXPRESS namespace, e.g. \name{expr:LOGICAL}, \name{expr:TRUE}, \name{expr:FALSE} or \name{expr:UNKNOWN}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Select Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Select Datatype Declarations}
\label{subsec:ifcOWL-select-types}

A select data\-type represents an union of other data\-types. Union members of a select data\-type usually are either entity data\-types, or defined data\-types all together. But there are a few exceptions, for instance, type \name{Ifc\-Trim\-ming\-Se\-lect} is an union of entity data\-type \name{Ifc\-Car\-te\-sian\-Point} and defined data\-type \name{Ifc\-Pa\-ra\-me\-ter\-Va\-lue}.

\begin{principle}[Select data\-types]
A select data\-type must be converted to an \name{owl:Class} which is a subclass of \name{expr:\-Select\-Class}. Union-member data\-types are defined by means of \name{rdfs:\-subclassOf} in the \simple{} layer, and by means of \name{owl:unionOf} in \standard{} and \extended{} layers as shown in the listing below.
\end{principle}

%\begin{lstlisting}[caption={Select data\-types}, label=lst:ifcOWL-select-types]
\begin{lstlisting}
# only for Simple layer
ifc:IfcTrimmingSelect a owl:Class ; rdfs:subclassOf expr:SelectClass .
ifc:IfcCartesianPoint, ifc:IfcParameterValue
    rdfs:subclassOf ifc:IfcTrimmingSelect .

# only for Standard, Extended layers
ifc:IfcTrimmingSelect a owl:Class ; rdfs:subclassOf expr:SelectClass ;
    owl:unionOf ( ifc:IfcCartesianPoint ifc:IfcParameterValue ) ] .
\end{lstlisting}

Similarly to the above case, two different approaches are used because property \name{owl:unionOf} supported only in OWL 2 RL, but not in OWL 2 EL and OWL 2 QL \cite{w3c:owl2-profiles}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Defined Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Defined Datatype Declarations}
\label{subsec:ifcOWL-defined-types}

A defined (declared, named) data\-type is usually specified as equivalent to a simple data\-type or another defined data\-type, with or without a additional constraint. For instance, type \name{Ifc\-Length\-Mea\-sure} is defined as equal to \name{REAL}, and type \name{Ifc\-Po\-si\-ti\-ve\-Length\-Mea\-su\-re} is a set of positive \name{Ifc\-Length\-Mea\-sure} values.

\begin{principle}[Defined data\-types]
If the defined data\-type is based on a simple data\-type then in ifcOWL it is declared as a \name{owl:Class} which is a subclass of \name{expr:\-Defined\-Class} has a single property \name{rdf:value} with that simple data\-type. If the defined data\-type is based on another defined data\-type then it is declared as a subclass of the \name{owl:Class} of that defined data\-type, for instance:

%\begin{lstlisting}[caption={Defined data\-types}, label=lst:ifcOWL-defined-types]
\begin{lstlisting}[aboveskip=3pt]
ifc:IfcLengthMeasure a owl:Class ; rdfs:subClassOf expr:DefinedClass ;
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty rdf:value;
                      owl:allValuesFrom xsd:double ] .
                      
ifc:IfcPositiveLengthMeasure a owl:Class ;
    rdfs:subClassOf ifc:IfcLengthMeasure .
\end{lstlisting}
\end{principle}


Defined data\-types are not declared as a \name{rdfs:Datatype}, but \name{owl:Class}es which wrap \name{rdfs:Datatype} values because in contract to simple data types they can be used for declaration of select data\-types (see \ref{subsec:ifcOWL-select-types}).

Defined data\-type \name{Ifc\-Time\-Stamp} is declared as equivalent to \name{INTEGER} but represents so-called Unix time value that can be easily converted to \name{xsd:date\-Time}. So it wraps a \name{xsd:date\-Time} value instead of \name{xsd:integer}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Entity Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Entity Datatype Declarations}
\label{subsec:ifcOWL-entity-types}

Entity data\-types are identical to classes in object-oriented programming languages. Each type may have not more than one super\-type that it inherits attributes from. An attribute is defined with a data\-type, a minimum and a maximum cardinalities, can be marked as optional.

\begin{principle}[Entity data\-types]An entity data\-type is converted to an \name{owl:\-Class} which is subclass of \name{expr:\-Entity\-Class} or its superclass. Entity attributes are defined by means of property \name{owl:on\-Pro\-per\-ty}. If an attribute is optional then its minimum qualified cardinality is 0, otherwise -- 1. Maximum qualified of all attributes are always 1. In case if an attribute is a list or a set of some data\-type then its type is considered as an external aggregated data\-type, for example:
%\begin{lstlisting}[caption={Entity data\-types}, label=lst:ifcOWL-defined-types]
\begin{lstlisting}
ifc:IfcProperty a owl:Class ; rdfs:subClassOf expr:EntityClass .

ifc:IfcComplexProperty a owl:Class ; rdfs:subClassOf ifc:IfcProperty ;
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty ifc:coordinates;
                      owl:allValuesFrom ifc:LIST_1_3_IfcLengthMeasure ] ;
    # only for Extended layer
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty ifc:coordinates;
                      owl:cardinality "1"^^xsd:integer ] .

# only for Standard & Extended layers
[] a owl:AllDisjointClasses ;
    owl:members ( ifc:IfcComplexProperty ifc:IfcSimpleProperty ) .
\end{lstlisting}
\end{principle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aggregated Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Aggregated Type Declarations}
\label{subsec:ifcOWL-aggregated-types}

Aggregation data\-types may be unordered (\name{SET} and \name{BAG}) or  ordered (\name{LIST} and \name{ARRAY}). \name{BAG} may contain a particular value more than once, unlike \name{SET}. \name{ARRAY} is specified with starting and ending indices while other types are specified with min and max cardinalities.

In order to declare these types, new classes were created in a similar way as Ordered List Ontoloty \cite{olo:ontology}:
\begin{itemize}
\item Class \name{expr:\-Collec\-tion\-Class} has four functional properties: \name{expr:isOrdered}, \name{expr:item\-Type}, \name{expr:\-size}, \name{expr:\-start\-Index}, \name{expr:\-end\-Index} and a nonfunctional property \name{expr:slot} with type \name{expr:Slot}.
\item Class \name{expr:Slot} has two functional properties \name{expr:item} (the actual collection item value), \name{expr:index} and also optional functional properties \name{expr:previous}, \name{expr:next}.
\item Classes \name{expr:SetClass}, \name{expr:ListClass}, \name{expr:ArrayClass} and \name{expr:BagClass} are subclasses of \name{expr:\-Collec\-tion\-Class}.
\end{itemize}

Below is a fragment of definition of type \name{SET [2:?] OF IfcProfileDef}:

\begin{lstlisting}
# all layers:
 ifc:SET_2_UNDEFINED_OF_IfcProfileDef a owl:Class ;
    rdfs:subClassOf ifc:SET_2_UNDEFINED , ifc:SET_OF_IfcProfileDef .
    
 ifc:SET_2_UNDEFINED, SET_OF_IfcProfileDef a owl:Class ;
    rdfs:subClassOf expr:SetClass .

# only for layer Extended:
 ifc:SET_2_UNDEFINED rdfs:subClassOf rdfs:subClassOf [ a owl:Restriction ;
    owl:onProperty expr:slot ; owl:minCardinality "2"^^xsd:integer ] .
    
 ifc:SET_OF_IfcProfileDef rdfs:subClassOf [ a owl:Restriction ;
    owl:onProperty expr:slot ; owl:allValuesFrom ifc:SLOT_OF_IfcProfileDef ].

 ifc:SLOT_OF_IfcProfileDef rdfs:subClassOf [ a owl:Restriction ; owl:onProperty expr:item ; owl:allValuesFrom ifc:IfcProfileDef ] .
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generating ifcRDF Datasets From IFC Data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generating ifcRDF Datasets From IFC Data}
\label{sec:ifcRDF}

\subsection{Dataset Metadata}
\label{subsec:ifcRDF-metadata}

IFC data are exchanged by using ``STEP physical files'' (SPF). SPF format is defined in ISO 10303-21 \cite{wiki:step-file}. A SPF header section includes a list of STEP-specific metadata entities with types \name{FileDescription} \name{FileName} and \name{FileSchema} described in \cite{buildingSMART:ifc-header}. They are exported as objects of STEP entities, some attributes are duplicated as Dublin Core (DC) metadata annotations, for example:

\begin{lstlisting}
<http://example.org>  a void:DataSet ;
    dcterms:created "2015-02-19T13:22:15Z"^^xsd:dateTime ;
    dcterms:creator "John Smith"^^xsd:string .
    step:fileName  [ a step:FileName ;
        step:author "John Smith"^^xsd:string ;
        step:originating_system "Tekla Structures 20.1"^^xsd:string ; ] ;
        step:time_stamp "2015-02-19T13:22:15Z"^^xsd:dateTime  ] .
\end{lstlisting}


In a SPF data section each entity is declared with a line number, an entity data\-type and a list of values. All entities of \name{Ifc\-Root}-derived types are converted into URI resources with format \name{GUID\_\textless{}guid\textgreater{}} where \name{guid} must be an normal GUID, not a compressed IFC GUID which may include a sign \name{\$}. Regarding to other entities, user can choose whether to export them as anonymous individuals or name them in a format like \name{LINE\_\textless{}lineNumber\textgreater{}}. Note that line numbers are used only for linking entities inside a SPF, and they are unstable. Naming is required when the dataset is used together with OWL 2 EL or OWL 2 QL because these profiles do not allow anonymous individuals. The namespace of named entities is also defined by user. Below is an example of IFC data exported to an RDF dataset which is compatible with OWL 2 RL:

\begin{lstlisting}
:GUID_1916794F-5605-4499-9AB0-F155DE8D3B6C
    a               ifc:IfcPropertySet ; # entity type
    ifc:globalId    [ a ifc:IfcGloballyUniqueId ; # defined type
                     rdf:value "0P5dbFLWL4cPgmyLNUZJji"^^xsd:string ] ;
    ifc:hasProperties  _:b11 .
    
_:b11 a ifc:SET_1_UNLIMITED_OF_IfcProperty ; # entity type
    expr:size "3"^^xsd:integer ;
    expr:itemType ifc:IfcProperty ;
    expr:slot _:b12, _:b13, _:b14 .
    
_:b12 a ifc:SLOT_OF_IfcProperty ;
    expr:item [ a ifc:IfcPropertySingleValue ; # entity type
                ifc:name "initial_GUID"^^xsd:string ;
                ifc:nominalValue  _:b15 ] .
\end{lstlisting}

%Data\-type of an attribute value is declared obviously only if the attribute has a select data\-type and the value has a defined data\-type. 

\section{Conclusion}
\label{sec:conclusion}