%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Converting EXPRESS Schemas to OWL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Generating ifcOWL Ontologies From IFC Specifications}
\label{sec:ifcOWL}

\subsection{Common Conversion Rules}

\begin{ontologyRule}[OWL profile]
\ifclite{} layer must be compatible with any OWL 2 DL profile: OWL 2 EL, OWL 2 QL or OWL 2 RL. \ifcstandard{}, \ifcadvanced{} must be compatible with OWL 2 RL\footnote{Our WebIFC converter tool allows forced choice of other OWL profiles for any layer: OWL Lite, OWL DL, OWL Full, and OWL 2 Full}.
\end{ontologyRule}

\TODO{Explain: why an OWL 2 profile has to be being chosen, how that choice will impact to the reasoning and querying performance, whether we can use other OWL 2 EL or QL for ifcOWL-Lite ontology}

OWL 2 RL has been chosen for \ifcstandard{}, \ifcadvanced{} because in contrast to OWL 2 EL and OWL 2 QL, it supports such needed things as: union data\-types (see \ref{subsec:ifcOWL-select-types}), enumerations of individuals (see \ref{subsec:ifcOWL-enum-types}), anonymous individuals (see \ref{subsec:ifcRDF-naming-individuals}), etc.\cite{w3c:owl2-profiles}.

\begin{ontologyRule}[Domain and range information]
Property domain and range constraints specified by \name{rdfs:domain} and \name{rdfs:range} should not be included in ifcOWL ontologies.
\end{ontologyRule}

Properties \name{rdfs:\-domain} and \name{rdfs:\-range} are mainly used to infer types, but not to check type constraints like in programming languages \cite{w3c:owl-guide}. Moreover, the basic facilities given by them do not provide any direct way to indicate property restrictions that are local to a class \cite{w3c:rdf-schema}. Although it is possible to combine use \name{rdfs:domain} and \name{rdfs:range} with sub-property hierarchies, direct support for such declarations is provided by OWL constructs, e.g. \name{owl:\-onProperty}.

\begin{ontologyRule}[Namespaces]
All constructs related to EXPRESS, STEP or IFC specifications must be belong to namespaces with prefixes \name{expr:}, \name{step:} and \name{ifc:} accordingly. At this moment the namespaces are defined as below (istead of \name{IFCXXX} there should be IFC versions, e.g. \name{IFC2x3} or \name{IFC4}):

%\begin{lstlisting}[caption={Namespace definitions},label=lst:ifcOWL-namespaces]
\begin{lstlisting}
@prefix expr: <http://drumbeat.cs.hut.fi/owl/EXPRESS#>
@prefix step: <http://drumbeat.cs.hut.fi/owl/STEP#>
@prefix ifc: <http://drumbeat.cs.hut.fi/owl/IFCXXX#>
\end{lstlisting}
\end{ontologyRule}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Components of an EXPRESS schema
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Components of an EXPRESS schema}
The IFC specification is written as an EXPRESS schema. An EXPRESS schema defines series of data\-types, functions and rules by using EXPRESS data definition language specified in ISO10303-11 \cite{wiki:express,noauthor:ifc-guide}.

There are six groups of data\-types: simple data\-types, entity data\-types, enumeration data\-types, defined (declared) data\-types, select data\-types and aggregation data\-types. All types must be declared obviously by using constructs TYPE and ENTITY except the built-in simple data\-types. Definitions and characteristics of data\-types are considered below. EXPRESS schemata also contain definitions of functions, rules and type constraints most of which cannot be reflected in OWL 2 at all.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Simple Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simple Datatype Declarations}
\label{subsec:ifcOWL-simple-type}

Simple data\-types built in EXPRESS are: \name{STRING}, \name{BI\-NA\-RY}, \name{IN\-TE\-GER}, \name{REAL}, \name{NUM\-BER}, \name{BOO\-LEAN} and \name{LO\-GI\-CAL}. However, type \name{LOGICAL} which has three possible values \name{TRUE}, \name{FALSE} and \name{UNKNOWN} is considered by us as an enumeration data\-type (see \ref{subsec:ifcOWL-enum-types}). The same to type \name{BOOLEAN} which is like a primitive boolean data\-type but semantically close and met with the same frequency in IFC4 as \name{LOGICAL}.

\begin{ontologyRule}[Simple data\-types]
All simple data\-types except \emph{BOOLEAN} and \emph{LOGICAL} are declared as the same as their most similar primitive XSD data\-types which are supported by OWL 2 \cite{w3c:owl2-profiles} and are among preferred standard data\-types in Linked Data Platform \cite{w3c:ldp-best-practices}:

% \begin{lstlisting}[caption={Simple data types}, label=lst:ifcOWL-simple-types]
\begin{lstlisting}
expr:STRING, ifc:IfcGlobalUniqueId owl:sameAs xsd:string .
expr:BINARY owl:sameAs xsd:hexBinary .
expr:INTEGER owl:sameAs xsd:integer .
expr:REAL, expr:NUMBER owl:sameAs xsd:double .
\end{lstlisting}
\end{ontologyRule}

`Most similar XSD data\-types' mean the types from XSD schema that conform to the value spaces of the original EXPRESS and IFC data\-types better than other ones. For instance, type \name{xsd:double} is more similar to \name{REAL} than \name{xsd:decimal} as it is an IEEE 64-bit floating-point data\-type and supports scientific notation \cite{w3c:xsd,datapic:xsd}. It is recommended to use XSD data\-type names directly when they are needed.

\begin{ontologyRule}[Simple data\-types with sizes, ifcOWL layers: all]If \name{STRING} and \name{BINARY} data\-types are specified with a size parameter, i.e. \name{STRING (max\-Length\-In\-Bytes)} or \name{BINARY(size\-In\-Bits)}, then in layers \lite{} and \standard{} they are defined as equivalent to data\-types without size. But in layer \advanced{}, the size parameter must be declared by using property \name{owl:onDatatype} and data\-type facets \name{xsd:maxLength} or \name{xsd:length} \cite{w3c:owl2-syntax,w3c:xmlschema11-2}, for instance:

% \begin{lstlisting}[caption={Size constraint of simple datatypes},label=lst:ifcOWL-simple-types-with-size]
\begin{lstlisting}
# only for Lite, Standard layers
expr:STRING22 owl:sameAs expr:STRING .

# only for Advanced layer
expr:STRING22 owl:equivalentClass
    [   a rdfs:Datatype ;
        owl:onDatatype  xsd:string ;
        owl:withRestrictions ( [ xsd:length "22"^^xsd:integer ] ) ] .
\end{lstlisting}
\end{ontologyRule}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Enumeration Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Enumeration Datatype Declarations}
\label{subsec:ifcOWL-enum-types}

An enumeration data\-type represents a set of possible fixed values. 

\begin{ontologyRule}[Enumeration data\-types]
Each enumeration data\-type in \textbf{ifc\-OWL} is defined as an \name{owl:Class} which is a subclass of \name{expr:\-Enum\-Class}. All possible values of enumeration data\-types are defined as named individuals. Enumeration data\-type memberships are defined by means of \name{rdf:type} in the \lite{} layer, and by means of \name{owl:oneOf} in \standard{} and \advanced{} layers as shown below:
% \begin{lstlisting}[caption={Enumeration data\-types}, label=lst:ifcOWL-enum-types]
\begin{lstlisting}
# only for Lite layer
ifc:IfcAssemblyPlaceEnum a owl:Class ; rdfs:subclassOf expr:EnumClass .
ifc:SITE, ifc:FACTORY, ifc:NOTDEFINED rdf:type ifc:IfcAddressTypeEnum .
    
# only for Standard, Advanced layers
ifc:IfcAssemblyPlaceEnum a owl:Class ;  rdfs:subclassOf expr:EnumClass ;
    owl:oneOf ( ifc:SITE ifc:FACTORY ifc:NOTDEFINED ) .
\end{lstlisting}
\end{ontologyRule}

The reason of two different approaches is that enumeration with more than one individual or literal are not supported in OWL 2 EL or QL. In both cases enumeration values are defined as individuals of one class so in terms of reasnoning logic they are equivalent. The enumeration values are defined as individuals because OWL 2 RL supports \name{Object\-One\-Of} to define enumeration of individuals, but not \name{Data\-One\-Of} \cite{w3c:owl2-profiles}. The fact that some values such as \name{ifc:NOT\-DE\-FI\-NED} belong to different enumeration data\-types should not cause any problems since all enumeration values in ifc\-RDF datasets are defined together with a concrete enumeration data\-type (see \ref{subsec:ifcRDF-enum-values}). It is also very easy to get all possible values of an enumeration data\-type by using simple SPARQL queries.

As mentioned above, simple data\-types \name{BOOLEAN} and \name{LOGICAL} are considered by us as enumeration data\-types. But these types and their values must be defined in the EXPRESS namespace, e.g. \name{expr:LOGICAL}, \name{expr:TRUE}, \name{expr:FALSE} or \name{expr:UNKNOWN}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Select Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Select Datatype Declarations}
\label{subsec:ifcOWL-select-types}

A select data\-type represents an union of other data\-types. Union members of a select data\-type usually are either entity data\-types, or defined data\-types all together. But there are a few exceptions, for instance, type \name{Ifc\-Trim\-ming\-Se\-lect} is an union of entity data\-type \name{Ifc\-Car\-te\-sian\-Point} and defined data\-type \name{Ifc\-Pa\-ra\-me\-ter\-Va\-lue}.

\begin{ontologyRule}[Select data\-types]
A select data\-type must be converted to an \name{owl:Class} which is a subclass of \name{expr:\-Select\-Class}. Union-member data\-types are defined by means of \name{rdfs:\-subclassOf} in the \lite{} layer, and by means of \name{owl:unionOf} in \standard{} and \advanced{} layers as shown in the listing below.
\end{ontologyRule}

%\begin{lstlisting}[caption={Select data\-types}, label=lst:ifcOWL-select-types]
\begin{lstlisting}
# only for Lite layer
ifc:IfcTrimmingSelect a owl:Class ; rdfs:subclassOf expr:SelectClass .
ifc:IfcCartesianPoint, ifc:IfcParameterValue
    rdfs:subclassOf ifc:IfcTrimmingSelect .

# only for Standard, Advanced layers
ifc:IfcTrimmingSelect a owl:Class ; rdfs:subclassOf expr:SelectClass ;
    owl:unionOf ( ifc:IfcCartesianPoint ifc:IfcParameterValue ) ] .
\end{lstlisting}

Similarly to the above case, two different approaches are used because property \name{owl:unionOf} supported only in OWL 2 RL, but not in OWL 2 EL and OWL 2 QL \cite{w3c:owl2-profiles}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Defined Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Defined Datatype Declarations}
\label{subsec:ifcOWL-defined-types}

A defined (declared, named) data\-type is usually specified as equivalent to a simple data\-type or another defined data\-type, with or without a additional constraint. For instance, type \name{Ifc\-Length\-Mea\-sure} is defined as equal to \name{REAL}, and type \name{Ifc\-Po\-si\-ti\-ve\-Length\-Mea\-su\-re} is a set of positive \name{Ifc\-Length\-Mea\-sure} values.

\begin{ontologyRule}[Defined data\-types]
If the defined data\-type is based on a simple data\-type then in ifcOWL it is declared as a \name{owl:Class} which is a subclass of \name{expr:\-Defined\-Class} has a single property \name{rdf:value} with that simple data\-type. If the defined data\-type is based on another defined data\-type then it is declared as a subclass of the \name{owl:Class} of that defined data\-type, for instance:

%\begin{lstlisting}[caption={Defined data\-types}, label=lst:ifcOWL-defined-types]
\begin{lstlisting}[aboveskip=3pt]
ifc:IfcLengthMeasure a owl:Class ; rdfs:subClassOf expr:DefinedClass ;
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty rdf:value;
                      owl:allValuesFrom xsd:double ] .
                      
ifc:IfcPositiveLengthMeasure a owl:Class ;
    rdfs:subClassOf ifc:IfcLengthMeasure .
\end{lstlisting}
\end{ontologyRule}


Defined data\-types are not declared as a \name{rdfs:Datatype}, but \name{owl:Class}es which wrap \name{rdfs:Datatype} values because in contract to simple data types they can be used for declaration of select data\-types (see \ref{subsec:ifcOWL-select-types}).

Defined data\-type \name{Ifc\-Time\-Stamp} is declared as equivalent to \name{INTEGER} but represents so-called Unix time value that can be easily converted to \name{xsd:date\-Time}. So it wraps a \name{xsd:date\-Time} value instead of \name{xsd:integer}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Entity Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Entity Datatype Declarations}
\label{subsec:ifcOWL-entity-types}

Entity data\-types are identical to classes in object-oriented programming languages. Each type may have not more than one super\-type that it inherits attributes from. An attribute is defined with a data\-type, a minimum and a maximum cardinalities, can be marked as optional.

\begin{ontologyRule}[Entity data\-types]An entity data\-type is converted to an \name{owl:\-Class} which is subclass of \name{expr:\-Entity\-Class} or its superclass. Entity attributes are defined by means of property \name{owl:on\-Pro\-per\-ty}. If an attribute is optional then its minimum qualified cardinality is 0, otherwise -- 1. Maximum qualified of all attributes are always 1. In case if an attribute is a list or a set of some data\-type then its type is considered as an external aggregated data\-type, for example:
%\begin{lstlisting}[caption={Entity data\-types}, label=lst:ifcOWL-defined-types]
\begin{lstlisting}
ifc:IfcProperty a owl:Class ; rdfs:subClassOf expr:EntityClass .

ifc:IfcComplexProperty a owl:Class ; rdfs:subClassOf ifc:IfcProperty ;
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty ifc:coordinates;
                      owl:allValuesFrom LIST_1_3_IfcLengthMeasure ] ;
    # only for Advanced layer
    rdfs:subClassOf [ a owl:Restriction; owl:onProperty ifc:coordinates;
                      owl:cardinality "1"^^xsd:integer ] .

# only for Standard & Advanced layers
[] a owl:AllDisjointClasses ;
    owl:members ( ifc:IfcComplexProperty ifc:IfcSimpleProperty ) .
\end{lstlisting}
\end{ontologyRule}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aggregated Datatype Declarations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Aggregated Type Declarations}
\label{subsec:ifcOWL-aggregated-types}





\section{Generating ifcRDF Datasets From IFC Data}


\subsection{Naming individuals}
\label{ifcRDF:naming-individuals}